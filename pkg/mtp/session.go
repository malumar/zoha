package mtp

import (
	"github.com/malumar/zoha/api"
	"net/mail"
)

// Session connection session itself does not mean that the client is logged in,
// it should be generated by Super interface,
// the session works synchronously and without threads in the sense of accepting commands from the server
type Session interface {
	IsLoggedIn() bool

	// From The address from the from header but also the login of the logged-in person (if so)
	From() AddressEmail

	MaxMessageSize() uint64

	// IsAllowSendAs Can a user send a message from this address only to logged in users?
	IsAllowSendAs(addressEmailInAsciiLowerCase AddressEmail) (bool, error)

	// OnAuthorization User authorization
	// @username is already IDN decoded value as lowercase ASCII
	// @password is plain text value received from client (we don't support anything other than plain text at this time)
	// @service service type
	// @useSsl connection use ssl
	OnAuthorization(username string, password string, service api.Service, useSsl api.Maybe) (bool, error)

	// ResetMessageReceivingStatus Consider the shipment, if any, as not yet there and will be prepared to pick up another
	ResetMessageReceivingStatus() error

	// AcceptMessageFromEmail The client wants to send us a new message, if you return an error,
	// you will not accept the message,
	// at this stage you can already check the sender of the message
	// because it is the actual so-called Envelope lowercase and already in ascii
	AcceptMessageFromEmail(senderAscii AddressEmail) error

	// AcceptRecipient Do you accept the recipient of this message? is already in ASCII format,
	// you can treat it as caching to load all mailboxes to which it will deliver the message
	AcceptRecipient(recipientAscii AddressEmail) error

	// AcceptMessage: At this stage, you need to decide whether you will accept the message to all recipients or reject
	// it for everyone. If you can accept only some users, the rejection will always apply to the sender,
	// in the sense that we do not accept from him because he is a spammer.
	// You can return your own message, e.g. with message tracking or a link to a website that explains the reason,
	AcceptMessage(message *mail.Message) error

	// Physically deliver the message to the user's inbox
	ProcessDelivery(proxy MessageReceiverProxy, delivery Delivery, revHostname string) error

	Close()
}
